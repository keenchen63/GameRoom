# 数据同步机制详细说明

本文档详细解释当前实现的所有数据刷新和同步机制，帮助你判断是否需要调整。

---

## 1. 定期心跳机制（每 10 秒）

### 实现位置
```typescript
heartbeatIntervalRef.current = setInterval(() => {
  // 每 10 秒执行一次
  if (ws.isConnected()) {
    ws.send({ type: 'PING' });  // 发送心跳
  } else {
    forceRefreshRoomData();  // 连接断开，触发刷新
  }
}, 10000);
```

### 作用
- **检测连接健康**：每 10 秒发送一次 `PING`，服务器返回 `PONG`
- **发现断线**：如果连接断开，立即触发数据刷新和重连

### 频率
- **每 10 秒一次**
- **消息大小**：约 20 字节（JSON）
- **服务器响应**：约 20 字节（PONG）

### 影响
- ✅ **优点**：能及时发现连接问题
- ⚠️ **缺点**：每 10 秒一次可能过于频繁
- 📊 **流量**：每小时约 14.4 KB（非常小）

### 建议
- **当前频率**：10 秒可能过于频繁
- **推荐调整**：改为 **30-60 秒**，既能检测连接又不会太频繁
- **优化方案**：只在页面可见时发送心跳，隐藏时停止

---

## 2. 定期自动刷新（每 30 秒）

### 实现位置
```typescript
refreshIntervalRef.current = setInterval(() => {
  // 每 30 秒执行一次
  if (roomRef.current && document.visibilityState === 'visible') {
    forceRefreshRoomData();  // 刷新房间数据
  }
}, 30000);
```

### 作用
- **自动同步数据**：即使没有用户操作，也定期获取最新房间状态
- **防止数据过期**：确保页面显示的数据是最新的

### 频率
- **每 30 秒一次**
- **仅在页面可见时执行**（已优化）
- **仅在房间中时执行**（已优化）

### 影响
- ✅ **优点**：确保数据始终最新
- ⚠️ **缺点**：30 秒可能过于频繁，特别是如果房间状态很少变化
- 📊 **流量**：每次刷新发送 `JOIN_ROOM` 消息，服务器返回完整房间状态

### 建议
- **当前频率**：30 秒可能过于频繁
- **推荐调整**：改为 **60-120 秒**，或者只在检测到可能的数据不一致时刷新
- **优化方案**：
  - 只在页面从隐藏恢复后的前几分钟内频繁刷新
  - 之后降低频率或停止自动刷新

---

## 3. 操作前强制刷新

### 实现位置
- `handleTransfer()` - 转分前
- `handleEndGameConfirm()` - 结束房间前
- `handleChangeAvatar()` - 更换头像前

### 代码示例
```typescript
const handleTransfer = (amount: number) => {
  // 操作前强制刷新数据
  const refreshSuccess = forceRefreshRoomData();
  
  if (!ws.isConnected()) {
    // 连接断开，等待重连后重试
    setTimeout(() => { /* 重试 */ }, 2000);
    return;
  }
  
  // 发送转分请求
  ws.send({ type: 'TRANSFER', ... });
};
```

### 作用
- **确保数据最新**：在关键操作前获取最新房间状态
- **避免数据冲突**：防止基于过期数据执行操作

### 频率
- **仅在用户操作时触发**
- **每次操作前都执行**

### 影响
- ✅ **优点**：确保操作基于最新数据，避免错误
- ⚠️ **缺点**：每次操作都有额外延迟（等待服务器响应）
- 📊 **用户体验**：用户可能感觉到操作有延迟

### 建议
- **当前实现**：可能过于保守
- **推荐调整**：
  - **方案 A（推荐）**：只在检测到连接可能有问题时才刷新
  - **方案 B**：只在长时间未刷新时才刷新（例如上次刷新超过 10 秒）
  - **方案 C**：移除操作前刷新，依赖定期刷新和页面可见性刷新

---

## 4. 页面可见性刷新

### 实现位置
```typescript
const handleVisibilityChange = () => {
  if (document.visibilityState === 'visible') {
    // 页面从隐藏变为可见
    forceRefreshRoomData();  // 立即刷新
  }
};
```

### 作用
- **息屏恢复**：手机息屏后重新打开时立即刷新
- **切换应用恢复**：从其他 app 切回来时立即刷新

### 频率
- **仅在页面从隐藏变为可见时触发**
- **有防抖保护**：至少间隔 1 秒

### 影响
- ✅ **优点**：解决你遇到的主要问题（切回 app 后数据不同步）
- ✅ **频率合理**：只在必要时触发
- 📊 **用户体验**：用户切回页面时立即看到最新数据

### 建议
- **当前实现**：✅ **合理，建议保留**
- **优化**：可以添加更智能的判断，例如：
  - 如果页面隐藏时间很短（< 5 秒），可能不需要刷新
  - 如果页面隐藏时间很长（> 30 秒），强制刷新

---

## 5. 自动重试机制

### 实现位置
在 `handleTransfer()`, `handleEndGameConfirm()`, `handleChangeAvatar()` 中

### 代码示例
```typescript
if (!ws.isConnected()) {
  showToast('连接断开，正在重连...');
  setTimeout(() => {
    if (ws.isConnected()) {
      // 重试操作
    } else {
      showToast('连接失败，请稍后重试');
    }
  }, 2000);
  return;
}
```

### 作用
- **容错处理**：连接断开时自动重试
- **用户体验**：显示友好提示，自动恢复

### 频率
- **仅在操作失败时触发**
- **延迟 2 秒后重试**

### 影响
- ✅ **优点**：提高操作成功率
- ⚠️ **缺点**：如果连接一直失败，用户需要等待 2 秒才能看到错误提示

### 建议
- **当前实现**：✅ **合理，建议保留**
- **优化**：可以添加重试次数限制（例如最多重试 2 次）

---

## 6. 统一的刷新函数

### 实现位置
```typescript
const forceRefreshRoomData = () => {
  // 检查连接状态
  // 如果断开，自动重连
  // 如果正常，发送 JOIN_ROOM 获取最新数据
};
```

### 作用
- **代码复用**：所有刷新逻辑统一
- **一致性**：确保所有刷新行为一致

### 影响
- ✅ **优点**：代码清晰，易于维护
- ✅ **无副作用**：只是代码组织方式

### 建议
- **当前实现**：✅ **合理，建议保留**

---

## 总结和建议

### 当前机制评估

| 机制 | 频率 | 必要性 | 建议 |
|------|------|--------|------|
| 心跳（10秒） | 高 | 中等 | ⚠️ 改为 30-60 秒 |
| 自动刷新（30秒） | 高 | 低 | ⚠️ 改为 60-120 秒，或条件触发 |
| 操作前刷新 | 每次操作 | 低 | ⚠️ 改为条件触发（连接异常时） |
| 可见性刷新 | 按需 | 高 | ✅ 保留，可优化判断逻辑 |
| 自动重试 | 失败时 | 高 | ✅ 保留 |
| 统一刷新函数 | - | 高 | ✅ 保留 |

### 推荐优化方案

#### 方案 A：保守优化（推荐）
1. **心跳改为 30 秒**：减少频率，但仍能及时检测问题
2. **自动刷新改为 60 秒**：降低频率，减少不必要的请求
3. **操作前刷新改为条件触发**：只在连接异常或长时间未刷新时触发
4. **保留可见性刷新和自动重试**：这些是核心功能

#### 方案 B：激进优化
1. **移除定期自动刷新**：完全依赖可见性刷新和操作前刷新
2. **心跳改为 60 秒**：进一步降低频率
3. **操作前刷新改为智能判断**：检测上次刷新时间，只在必要时刷新

#### 方案 C：保持现状
- 如果当前机制工作良好，且服务器能承受负载，可以保持现状
- 但建议至少调整心跳频率（10秒 → 30秒）

---

## 具体代码调整建议

### 1. 调整心跳频率（10秒 → 30秒）
```typescript
heartbeatIntervalRef.current = setInterval(() => {
  // ... 改为 30000 (30秒)
}, 30000);
```

### 2. 调整自动刷新频率（30秒 → 60秒）
```typescript
refreshIntervalRef.current = setInterval(() => {
  // ... 改为 60000 (60秒)
}, 60000);
```

### 3. 操作前刷新改为条件触发
```typescript
const handleTransfer = (amount: number) => {
  const ws = wsClientRef.current;
  
  // 只在连接异常或长时间未刷新时刷新
  const lastRefresh = lastRefreshTimeRef.current;
  const timeSinceLastRefresh = Date.now() - (lastRefresh || 0);
  const shouldRefresh = !ws.isConnected() || timeSinceLastRefresh > 10000;
  
  if (shouldRefresh) {
    forceRefreshRoomData();
  }
  
  // ... 继续操作
};
```

---

## 你的决定

请告诉我：
1. 哪些机制你觉得过于频繁？
2. 你希望保留哪些机制？
3. 你希望调整哪些机制的频率？

我可以根据你的反馈进行精确调整。

