# 房间持续可用性机制详细分析

本文档详细解释房间数据的存储机制、持久化方式，以及可能导致房间丢失的场景。

---

## 一、数据存储架构

### 1. 服务器端存储（内存存储）

**存储位置**：`server/index.js`

```javascript
// 房间存储（内存，不持久化）
const rooms = new Map(); // roomId -> { players: Map, isEnded: boolean, transferHistory: Array }
const playerToRoom = new Map(); // playerId -> roomId
const playerToSocket = new Map(); // playerId -> WebSocket
```

**特点**：
- ✅ **实时性**：数据在内存中，访问速度快
- ❌ **易失性**：服务器重启后，所有数据丢失
- ❌ **无持久化**：没有数据库或文件存储
- ❌ **单机限制**：无法跨服务器共享

### 2. 客户端存储（localStorage）

**存储位置**：浏览器 `localStorage`

**存储的数据**：
- `roomId`：当前房间号（4位数字）
- `playerId`：当前玩家ID（格式：`p_timestamp_random`）

**存储时机**：
- 创建房间时：保存 `roomId` 和 `playerId`
- 加入房间时：保存 `roomId` 和 `playerId`
- 收到房间状态更新时：更新 `roomId` 和 `playerId`

**清除时机**：
- 房间结束时：清除 `roomId` 和 `playerId`
- 离开房间时：清除 `roomId`（如果积分为0）
- 房间不存在时：清除 `roomId`
- 手动返回首页时：清除 `roomId` 和 `playerId`

---

## 二、房间生命周期

### 1. 房间创建流程

```
用户点击"创建房间"
  ↓
生成新的 playerId（p_timestamp_random）
  ↓
清除旧的 localStorage 数据
  ↓
发送 CREATE_ROOM 消息到服务器
  ↓
服务器创建房间（内存中）
  ↓
服务器返回 ROOM_CREATED 消息
  ↓
前端保存 roomId 和 playerId 到 localStorage
  ↓
进入房间页面
```

### 2. 房间加入流程

```
用户输入房间号（或扫码）
  ↓
获取或生成 playerId
  ↓
保存 roomId 和 playerId 到 localStorage
  ↓
发送 JOIN_ROOM 消息到服务器
  ↓
服务器验证房间是否存在
  ↓
服务器返回 ROOM_JOINED 消息
  ↓
进入房间页面
```

### 3. 自动重连（Auto-Rejoin）流程

```
页面加载/刷新
  ↓
读取 localStorage 中的 roomId 和 playerId
  ↓
WebSocket 连接建立
  ↓
自动发送 JOIN_ROOM 消息
  ↓
如果房间存在：成功重连
  ↓
如果房间不存在：清除 localStorage，返回首页
```

---

## 三、可能导致房间丢失的场景

### 🔴 场景 1：服务器重启（最严重）

**原因**：
- 服务器端使用内存存储（`Map`），重启后所有数据清空

**影响**：
- ✅ **所有房间立即消失**
- ✅ **所有玩家数据丢失**
- ✅ **所有转分记录丢失**

**用户表现**：
- 刷新页面后，自动重连失败
- 显示"房间不存在"错误
- 自动返回首页

**解决方案**：
- ❌ **当前无解决方案**（需要添加数据库持久化）

---

### 🟠 场景 2：浏览器清除缓存/数据

**原因**：
- `localStorage` 被清除（手动清除、隐私模式、浏览器设置）

**影响**：
- ✅ **客户端无法自动重连**
- ⚠️ **服务器端房间仍然存在**（如果服务器未重启）
- ⚠️ **其他玩家不受影响**

**用户表现**：
- 刷新页面后，无法自动重连
- 需要手动输入房间号重新加入
- 如果记得房间号，可以重新加入（服务器端房间还在）

**解决方案**：
- ⚠️ **部分解决**：用户需要记住房间号，手动重新加入

---

### 🟡 场景 3：长时间无活动导致连接断开

**原因**：
- WebSocket 连接超时断开
- 网络不稳定导致连接断开

**影响**：
- ⚠️ **客户端连接断开，但服务器端房间仍然存在**
- ⚠️ **服务器端仍保留玩家数据**

**用户表现**：
- 页面显示连接断开
- 自动重连机制会尝试重新连接
- 如果重连成功，可以恢复房间状态

**解决方案**：
- ✅ **已实现**：自动重连机制 + 手动刷新按钮

---

### 🟡 场景 4：房间被房主结束

**原因**：
- 房主点击"结束房间"

**影响**：
- ✅ **服务器端房间被标记为 `isEnded: true`**
- ✅ **服务器端房间数据被删除**
- ✅ **所有玩家的 `playerToRoom` 映射被清除**

**用户表现**：
- 所有玩家自动进入结算页面
- 刷新页面后，无法重新加入（房间已结束）
- `localStorage` 被自动清除

**解决方案**：
- ✅ **正常流程**：这是预期的行为

---

### 🟡 场景 5：所有玩家离开房间

**原因**：
- 所有玩家都离开了房间（积分为0时才能离开）

**影响**：
- ✅ **服务器端房间被删除**（`rooms.delete(roomId)`）
- ⚠️ **如果还有玩家在房间中，房间不会删除**

**用户表现**：
- 最后一个离开的玩家会看到房间被删除
- 其他玩家刷新后无法重新加入

**解决方案**：
- ✅ **正常流程**：空房间自动清理

---

### 🟢 场景 6：玩家手动离开房间（积分为0）

**原因**：
- 玩家点击"离开房间"（积分为0）

**影响**：
- ⚠️ **服务器端从房间中移除该玩家**
- ⚠️ **服务器端房间仍然存在**（其他玩家还在）
- ✅ **客户端清除 `localStorage` 中的 `roomId`**

**用户表现**：
- 返回首页
- 无法自动重连（因为 `localStorage` 已清除）
- 可以手动输入房间号重新加入（如果记得）

**解决方案**：
- ✅ **正常流程**：这是预期的行为

---

### 🟢 场景 7：网络中断后恢复

**原因**：
- 网络暂时中断，然后恢复

**影响**：
- ⚠️ **WebSocket 连接断开**
- ⚠️ **服务器端房间仍然存在**

**用户表现**：
- 自动重连机制会尝试重新连接
- 重连成功后，自动发送 `JOIN_ROOM` 消息
- 如果房间还在，可以恢复状态

**解决方案**：
- ✅ **已实现**：自动重连 + 自动重连后刷新数据

---

## 四、数据持久化现状

### 当前实现

| 数据类型 | 存储位置 | 持久化 | 服务器重启后 |
|---------|---------|--------|------------|
| 房间数据 | 服务器内存 | ❌ 否 | ❌ 丢失 |
| 玩家数据 | 服务器内存 | ❌ 否 | ❌ 丢失 |
| 转分记录 | 服务器内存 | ❌ 否 | ❌ 丢失 |
| 房间号 | 客户端 localStorage | ✅ 是 | ✅ 保留（但服务器端房间已丢失）|
| 玩家ID | 客户端 localStorage | ✅ 是 | ✅ 保留（但服务器端映射已丢失）|

### 数据丢失风险评估

| 场景 | 风险等级 | 影响范围 | 恢复可能性 |
|------|---------|---------|-----------|
| 服务器重启 | 🔴 **极高** | 所有房间 | ❌ 无法恢复 |
| 清除浏览器缓存 | 🟠 **高** | 单个用户 | ⚠️ 需手动重新加入 |
| 长时间无活动 | 🟡 **中** | 单个用户 | ✅ 自动重连 |
| 网络中断 | 🟡 **中** | 单个用户 | ✅ 自动重连 |
| 房间被结束 | 🟢 **低** | 所有玩家 | ✅ 正常流程 |
| 玩家离开 | 🟢 **低** | 单个玩家 | ⚠️ 需手动重新加入 |

---

## 五、用户操作对房间的影响

### 1. 刷新页面（F5 / Cmd+R）

**服务器端**：
- ✅ 房间数据保留
- ✅ 玩家数据保留
- ⚠️ WebSocket 连接断开

**客户端**：
- ✅ `localStorage` 数据保留
- ✅ 自动重连机制触发
- ✅ 自动发送 `JOIN_ROOM` 消息

**结果**：
- ✅ **通常可以成功恢复**（除非服务器已重启）

---

### 2. 关闭浏览器标签页

**服务器端**：
- ✅ 房间数据保留
- ⚠️ WebSocket 连接断开
- ⚠️ `playerToSocket` 映射被清除（但 `playerToRoom` 保留）

**客户端**：
- ✅ `localStorage` 数据保留

**重新打开**：
- ✅ 自动重连机制触发
- ✅ 自动发送 `JOIN_ROOM` 消息

**结果**：
- ✅ **通常可以成功恢复**（除非服务器已重启）

---

### 3. 清除浏览器缓存/数据

**服务器端**：
- ✅ 房间数据保留（如果服务器未重启）

**客户端**：
- ❌ `localStorage` 被清除
- ❌ 无法自动重连

**结果**：
- ⚠️ **需要手动输入房间号重新加入**（如果记得房间号）

---

### 4. 切换到隐私模式/无痕模式

**服务器端**：
- ✅ 房间数据保留

**客户端**：
- ❌ `localStorage` 无法使用（隐私模式限制）
- ❌ 无法自动重连

**结果**：
- ⚠️ **需要手动输入房间号加入**（每次都需要）

---

## 六、当前机制的优缺点

### ✅ 优点

1. **简单快速**：内存存储，访问速度快
2. **实时同步**：WebSocket 实时推送，数据一致性好
3. **自动重连**：网络中断后可以自动恢复
4. **客户端持久化**：`localStorage` 保存房间号，刷新后可以自动重连

### ❌ 缺点

1. **服务器重启丢失**：最严重的问题，服务器重启后所有数据丢失
2. **无跨服务器支持**：无法在多服务器环境下共享数据
3. **无历史记录**：房间结束后，无法查看历史记录
4. **依赖客户端存储**：清除缓存后需要手动重新加入

---

## 七、改进建议

### 1. 添加数据库持久化（推荐）

**方案**：
- 使用数据库（如 MongoDB、PostgreSQL）存储房间数据
- 服务器重启后可以从数据库恢复

**优点**：
- ✅ 解决服务器重启丢失问题
- ✅ 可以保存历史记录
- ✅ 支持数据查询和分析

**缺点**：
- ⚠️ 需要额外的数据库服务
- ⚠️ 增加系统复杂度

---

### 2. 添加文件持久化（简单方案）

**方案**：
- 定期将房间数据写入 JSON 文件
- 服务器启动时从文件恢复

**优点**：
- ✅ 实现简单
- ✅ 不需要额外的数据库服务

**缺点**：
- ⚠️ 文件读写可能成为性能瓶颈
- ⚠️ 并发写入需要加锁

---

### 3. 添加房间过期机制 ✅ **已实现**

**方案**：
- 设置房间最大存活时间：**48 小时未活动**
- 每 **30 分钟**检查一次，自动清理过期房间
- 服务器启动时立即执行一次清理

**实现细节**：
- 每个房间记录 `createdAt`（创建时间）和 `lastActivityAt`（最后活动时间）
- 所有房间操作（加入、转分、更换头像等）都会更新 `lastActivityAt`
- 超过 48 小时未活动的房间会被自动清理
- 清理时会删除房间数据和所有玩家的映射关系

**优点**：
- ✅ 防止内存泄漏
- ✅ 清理僵尸房间
- ✅ 自动运行，无需手动干预

**缺点**：
- ⚠️ 长时间无活动的房间会被清理（48 小时足够长，通常不会影响正常使用）

---

### 4. 添加房间备份机制

**方案**：
- 定期将房间数据备份到文件或数据库
- 服务器重启后恢复

**优点**：
- ✅ 减少数据丢失风险
- ✅ 可以恢复最近的状态

**缺点**：
- ⚠️ 备份频率影响性能
- ⚠️ 可能丢失备份后的数据

---

## 八、用户使用建议

### 对于用户

1. **记住房间号**：
   - 如果清除缓存，可以手动输入房间号重新加入
   - 建议截图保存房间号

2. **避免长时间离开**：
   - 如果服务器重启，房间会丢失
   - 建议在游戏过程中保持连接

3. **使用同一浏览器**：
   - `localStorage` 是浏览器级别的
   - 切换浏览器需要重新加入

4. **不要清除浏览器数据**：
   - 清除缓存会导致无法自动重连
   - 需要手动输入房间号

### 对于开发者

1. **监控服务器状态**：
   - 确保服务器稳定运行
   - 避免频繁重启

2. **考虑添加持久化**：
   - 如果用户对数据丢失敏感，建议添加数据库
   - 或者至少添加文件持久化

3. **添加房间过期提醒**：
   - 如果房间长时间无活动，提醒用户
   - 或者自动保存游戏状态

---

## 九、总结

### 当前机制的风险

| 风险 | 概率 | 影响 | 当前状态 |
|------|------|------|---------|
| 服务器重启丢失 | 🟡 中等 | 🔴 严重 | ❌ 无保护 |
| 清除缓存丢失 | 🟢 低 | 🟡 中等 | ⚠️ 需手动重新加入 |
| 网络中断 | 🟢 低 | 🟢 轻微 | ✅ 自动重连 |
| 长时间无活动 | 🟡 中等 | 🟡 中等 | ✅ 自动重连 |

### 最需要关注的问题

1. **服务器重启**：这是最严重的问题，会导致所有房间丢失
2. **清除缓存**：用户清除缓存后，需要手动重新加入（如果记得房间号）

### 建议的改进优先级

1. **高优先级**：添加数据库持久化（解决服务器重启问题）
2. **中优先级**：✅ **已完成** - 添加房间过期机制（防止内存泄漏）
3. **低优先级**：添加房间备份机制（减少数据丢失风险）

---

## 十、技术细节

### localStorage 的限制

1. **存储大小**：通常 5-10MB
2. **作用域**：同一域名下的所有页面共享
3. **持久性**：除非手动清除，否则永久保存
4. **隐私模式**：某些浏览器在隐私模式下禁用或限制

### WebSocket 连接管理

1. **连接状态**：`CONNECTING` → `OPEN` → `CLOSED`
2. **自动重连**：最多尝试 5 次，每次间隔递增
3. **连接超时**：浏览器和服务器都有超时限制

### 服务器内存管理

1. **房间清理**：
   - 房间结束时立即删除
   - 房间为空时立即删除
   - 玩家离开时从房间中移除

2. **映射清理**：
   - `playerToRoom`：玩家离开或房间结束时清除
   - `playerToSocket`：WebSocket 断开时清除

---

## 附录：常见问题

### Q1: 服务器重启后，房间会丢失吗？

**A**: 是的，**所有房间数据都会丢失**。因为服务器使用内存存储，重启后所有数据清空。

### Q2: 清除浏览器缓存后，还能恢复房间吗？

**A**: 可以，但需要**手动输入房间号重新加入**。服务器端的房间数据还在（如果服务器未重启）。

### Q3: 网络断开后，房间会丢失吗？

**A**: 不会。网络恢复后，**自动重连机制**会尝试重新连接并恢复房间状态。

### Q4: 长时间不操作，房间会丢失吗？

**A**: 会。如果房间超过 **48 小时未活动**，会被自动清理。这是为了防止内存泄漏和清理僵尸房间。

### Q5: 如何防止房间丢失？

**A**: 
- 对于用户：记住房间号，避免清除缓存
- 对于开发者：添加数据库持久化（推荐）

---

**最后更新**：2024年（当前实现版本）

---

## 十一、房间过期机制（已实现）

### 实现状态

✅ **已实现**：房间过期清理机制已添加到服务器端

### 配置参数

- **过期时间**：48 小时未活动
- **检查间隔**：每 30 分钟检查一次
- **启动清理**：服务器启动时立即执行一次清理

### 活动时间更新规则

以下操作会更新房间的 `lastActivityAt`：

1. **创建房间**：设置 `createdAt` 和 `lastActivityAt`
2. **加入房间**：更新 `lastActivityAt`
3. **转分操作**：通过 `broadcastRoomState` 更新
4. **更换头像**：通过 `broadcastRoomState` 更新
5. **房间状态广播**：每次广播都会更新活动时间

### 清理逻辑

1. **跳过已结束的房间**：已结束的房间会在其他逻辑中被清理
2. **检查活动时间**：计算距离最后活动时间的间隔
3. **清理映射关系**：删除所有玩家的 `playerToRoom` 映射
4. **删除房间**：从 `rooms` Map 中删除房间数据
5. **记录日志**：输出清理的房间信息

### 兼容性处理

- **旧房间兼容**：如果房间没有 `lastActivityAt`，使用 `createdAt`
- **时间戳初始化**：在 `handleJoinRoom` 中为旧房间初始化时间戳

### 日志输出

清理时会输出以下日志：

```
[清理过期房间] 清理了 N 个超过 48 小时未活动的房间:
  - 房间 XXXX (最后活动: 2024-01-01T12:00:00.000Z)
```

### 注意事项

1. **不影响正常使用**：48 小时足够长，正常游戏不会受到影响
2. **自动运行**：无需手动干预，系统自动清理
3. **内存保护**：防止长时间无活动的房间占用内存

